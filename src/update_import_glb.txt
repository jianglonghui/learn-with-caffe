Adding GLB import and voxelization is a fantastic feature that dramatically expands the creative possibilities. This involves loading a 3D model and then converting its continuous geometry into a discrete grid of voxels.

We will follow the same clean architecture as before:

Create glb-processor.js: This new file will contain all the complex logic for loading a GLB file and, most importantly, the voxelization algorithm that converts a mesh into voxels.

Modify VoxelWorldEditor.js: We will add the UI elements (an "Import GLB" button and a file input) and the handler logic to call our new processor and add the resulting item to the backpack.

第1步: 创建 glb-processor.js (核心逻辑)

This file requires the GLTFLoader from Three.js. This is the most complex part, as it involves the algorithm to sample a 3D mesh.

在您的项目中创建一个新文件 glb-processor.js，并粘贴以下代码：



// --- START OF NEW FILE: glb-processor.js ---

import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
// DRACOLoader is a dependency for compressed GLB files, which are common.
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';

/**
 * Loads a GLB file and extracts the first available mesh.
 * @param {File} file - The GLB file object from a file input.
 * @returns {Promise<THREE.Mesh>} - A promise that resolves with the first mesh found.
 */
async function loadMeshFromGlb(file) {
  const loader = new GLTFLoader();
  
  // Setup DracoLoader
  const dracoLoader = new DRACOLoader();
  // You must host these decoder files on your server
  dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
  loader.setDRACOLoader(dracoLoader);

  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (event) => {
      loader.parse(event.target.result, '', (gltf) => {
        let mesh = null;
        gltf.scene.traverse((child) => {
          if (child.isMesh && !mesh) {
            // Found the first mesh, let's use it.
            mesh = child;
          }
        });
        if (mesh) {
          resolve(mesh);
        } else {
          reject(new Error('No mesh found in the GLB file.'));
        }
      }, (error) => {
        reject(new Error(`Failed to parse GLB file: ${error.message}`));
      });
    };
    reader.onerror = (error) => reject(error);
    reader.readAsArrayBuffer(file);
  });
}

/**
 * Voxelizes a THREE.Mesh object.
 * This function samples points within the mesh's bounding box and uses raycasting
 * to determine if a point is "inside" the mesh.
 * @param {THREE.Mesh} mesh - The mesh to voxelize.
 * @param {number} resolution - The number of voxels along the longest axis. Higher is more detailed.
 * @returns {Array<Object>} - An array of voxel data [{ x, y, z, color }].
 */
function voxelizeMesh(mesh, resolution = 20) {
  mesh.geometry.computeBoundingBox();
  const box = mesh.geometry.boundingBox;
  const size = box.getSize(new THREE.Vector3());

  const maxDim = Math.max(size.x, size.y, size.z);
  const voxelSize = maxDim / resolution;
  
  const voxels = [];
  const raycaster = new THREE.Raycaster();
  const direction = new THREE.Vector3(1, 0, 0); // Cast rays along the positive X-axis

  console.log(`Starting voxelization with resolution ${resolution} (voxel size: ${voxelSize})...`);

  for (let i = 0; i < resolution; i++) {
    for (let j = 0; j < resolution; j++) {
      for (let k = 0; k < resolution; k++) {
        
        // Calculate the center of the potential voxel
        const point = new THREE.Vector3(
          box.min.x + (i + 0.5) * voxelSize,
          box.min.y + (j + 0.5) * voxelSize,
          box.min.z + (k + 0.5) * voxelSize
        );

        // Check if the point is inside the mesh by casting a ray
        raycaster.set(point, direction);
        const intersects = raycaster.intersectObject(mesh, false);

        // If the number of intersections is odd, the point is inside
        if (intersects.length % 2 === 1) {
          
          // For color, we'll just use the material's base color for simplicity.
          // A more advanced version could sample a texture.
          const color = mesh.material.isMeshStandardMaterial ? mesh.material.color : new THREE.Color(0xffffff);

          voxels.push({
            x: Math.round(point.x / voxelSize),
            y: Math.round(point.y / voxelSize),
            z: Math.round(point.z / voxelSize),
            color: color
          });
        }
      }
    }
  }

  // Center the resulting voxels around the origin
  if (voxels.length > 0) {
    let minX = Infinity, minY = Infinity, minZ = Infinity;
    voxels.forEach(v => {
      minX = Math.min(minX, v.x);
      minY = Math.min(minY, v.y);
      minZ = Math.min(minZ, v.z);
    });
    const centerX = Math.round(minX + (Math.max(...voxels.map(v=>v.x)) - minX) / 2);
    const centerY = Math.round(minY + (Math.max(...voxels.map(v=>v.y)) - minY) / 2);
    const centerZ = Math.round(minZ + (Math.max(...voxels.map(v=>v.z)) - minZ) / 2);
    
    voxels.forEach(v => {
      v.x -= centerX;
      v.y -= centerY;
      v.z -= centerZ;
    });
  }

  console.log(`Voxelization complete. Generated ${voxels.length} voxels.`);
  return voxels;
}


/**
 * Main function: Loads a GLB file and processes it into voxel data.
 * @param {File} file - The GLB file from an input.
 * @param {Object} options - Containing options like 'resolution'.
 * @returns {Promise<Array<Object>>} A promise that resolves with the voxel array.
 */
export async function processGlbToVoxels(file, options = {}) {
  const resolution = options.resolution || 25; // Default resolution

  if (!file || !file.name.toLowerCase().endsWith('.glb')) {
    throw new Error('Please select a valid .glb file.');
  }

  try {
    const mesh = await loadMeshFromGlb(file);
    const voxels = voxelizeMesh(mesh, resolution);
    return voxels;
  } catch (error) {
    console.error('[GLB Processor] Error:', error);
    throw error; // Re-throw to be caught by the UI layer
  }
}
第2步: 修改 world_simulator.js 以集成GLB导入

添加 Import 和新状态

// 在文件顶部
import { processGlbToVoxels } from './glb-processor';

const VoxelWorldEditor = () => {
  // ... 其他现有状态
  const fileInputRef = useRef(null); // Ref for the hidden file input

  // 新增：GLB处理相关的状态
  const [isProcessingGlb, setIsProcessingGlb] = useState(false);
  const [glbError, setGlbError] = useState(null);

  // ...

添加事件处理器

在 VoxelWorldEditor 组件函数体内部，return 语句之前，添加以下处理器。

code
JavaScript
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
// 新增：GLB文件选择的事件处理器
const handleGlbFileSelected = async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  setIsProcessingGlb(true);
  setGlbError(null);

  try {
    // 调用我们的GLB处理器核心逻辑
    const voxels = await processGlbToVoxels(file, { resolution: 25 });

    if (voxels && voxels.length > 0) {
      // 使用通用的addItemToBackpack函数
      addItemToBackpack(voxels);
      alert(`成功从GLB文件生成了 ${voxels.length} 个方块的物品！`);
    } else {
      setGlbError("无法从GLB文件中生成任何方块。模型可能太小或格式有问题。");
    }
  } catch (error) {
    setGlbError(error.message || "处理GLB文件时发生未知错误。");
  } finally {
    setIsProcessingGlb(false);
    // 重置文件输入，以便用户可以再次选择相同的文件
    event.target.value = null; 
  }
};

// 新增：点击导入按钮时触发隐藏的文件输入框
const handleImportGlbClick = () => {
  fileInputRef.current?.click();
};

修改 JSX

在草图编辑器的“操作按钮”部分，添加新的“导入GLB”按钮。并在组件的某个地方（例如根 div 的末尾）添加隐藏的文件输入框。


// 修改：操作按钮
<div className="flex gap-2 flex-wrap">
  {/* ... 其他按钮 ... */}
  <button
    onClick={handleImportGlbClick}
    disabled={isProcessingGlb}
    className="flex-1 px-4 py-2 bg-orange-500 text-white rounded hover:bg-orange-600 font-medium disabled:bg-orange-300"
    title="从.glb文件导入模型"
  >
    {isProcessingGlb ? '处理中...' : '📦 导入GLB'}
  </button>
</div>

{/* 新增：全局错误提示 */}
{glbError && (
  <div className="mt-4 p-2 bg-red-100 text-red-700 rounded text-sm">
    <strong>导入错误:</strong> {glbError}
  </div>
)}

在 VoxelWorldEditor 组件返回的根 div 的末尾（但在 </div> 之前）添加隐藏的文件输入框。

code
Jsx
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
{/* ...其他JSX... */}

  {/* 新增：隐藏的文件输入框，用于GLB导入 */}
  <input
    type="file"
    ref={fileInputRef}
    onChange={handleGlbFileSelected}
    accept=".glb"
    style={{ display: 'none' }}
  />
</div>
);
总结

通过这些修改，您现在拥有了一个功能强大的新模式：

用户点击“导入GLB”，一个文件选择器会打开。

用户选择一个 .glb 文件。

glb-processor.js 被调用，它会异步加载模型。

加载成功后，它会遍历模型的边界框，通过光线投射算法判断哪些空间点在模型内部，从而将模型体素化。

最终生成的体素数组被传递回 VoxelWorldEditor。

一个包含新体素的新物品被创建并加入背包，可以像其他任何物品一样被放置到3D世界中。