Adding GLB import and voxelization is a fantastic feature that dramatically expands the creative possibilities. This involves loading a 3D model and then converting its continuous geometry into a discrete grid of voxels.

We will follow the same clean architecture as before:

Create glb-processor.js: This new file will contain all the complex logic for loading a GLB file and, most importantly, the voxelization algorithm that converts a mesh into voxels.

Modify VoxelWorldEditor.js: We will add the UI elements (an "Import GLB" button and a file input) and the handler logic to call our new processor and add the resulting item to the backpack.

ç¬¬1æ­¥: åˆ›å»º glb-processor.js (æ ¸å¿ƒé€»è¾‘)

This file requires the GLTFLoader from Three.js. This is the most complex part, as it involves the algorithm to sample a 3D mesh.

åœ¨æ‚¨çš„é¡¹ç›®ä¸­åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶ glb-processor.jsï¼Œå¹¶ç²˜è´´ä»¥ä¸‹ä»£ç ï¼š



// --- START OF NEW FILE: glb-processor.js ---

import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
// DRACOLoader is a dependency for compressed GLB files, which are common.
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';

/**
 * Loads a GLB file and extracts the first available mesh.
 * @param {File} file - The GLB file object from a file input.
 * @returns {Promise<THREE.Mesh>} - A promise that resolves with the first mesh found.
 */
async function loadMeshFromGlb(file) {
  const loader = new GLTFLoader();
  
  // Setup DracoLoader
  const dracoLoader = new DRACOLoader();
  // You must host these decoder files on your server
  dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
  loader.setDRACOLoader(dracoLoader);

  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (event) => {
      loader.parse(event.target.result, '', (gltf) => {
        let mesh = null;
        gltf.scene.traverse((child) => {
          if (child.isMesh && !mesh) {
            // Found the first mesh, let's use it.
            mesh = child;
          }
        });
        if (mesh) {
          resolve(mesh);
        } else {
          reject(new Error('No mesh found in the GLB file.'));
        }
      }, (error) => {
        reject(new Error(`Failed to parse GLB file: ${error.message}`));
      });
    };
    reader.onerror = (error) => reject(error);
    reader.readAsArrayBuffer(file);
  });
}

/**
 * Voxelizes a THREE.Mesh object.
 * This function samples points within the mesh's bounding box and uses raycasting
 * to determine if a point is "inside" the mesh.
 * @param {THREE.Mesh} mesh - The mesh to voxelize.
 * @param {number} resolution - The number of voxels along the longest axis. Higher is more detailed.
 * @returns {Array<Object>} - An array of voxel data [{ x, y, z, color }].
 */
function voxelizeMesh(mesh, resolution = 20) {
  mesh.geometry.computeBoundingBox();
  const box = mesh.geometry.boundingBox;
  const size = box.getSize(new THREE.Vector3());

  const maxDim = Math.max(size.x, size.y, size.z);
  const voxelSize = maxDim / resolution;
  
  const voxels = [];
  const raycaster = new THREE.Raycaster();
  const direction = new THREE.Vector3(1, 0, 0); // Cast rays along the positive X-axis

  console.log(`Starting voxelization with resolution ${resolution} (voxel size: ${voxelSize})...`);

  for (let i = 0; i < resolution; i++) {
    for (let j = 0; j < resolution; j++) {
      for (let k = 0; k < resolution; k++) {
        
        // Calculate the center of the potential voxel
        const point = new THREE.Vector3(
          box.min.x + (i + 0.5) * voxelSize,
          box.min.y + (j + 0.5) * voxelSize,
          box.min.z + (k + 0.5) * voxelSize
        );

        // Check if the point is inside the mesh by casting a ray
        raycaster.set(point, direction);
        const intersects = raycaster.intersectObject(mesh, false);

        // If the number of intersections is odd, the point is inside
        if (intersects.length % 2 === 1) {
          
          // For color, we'll just use the material's base color for simplicity.
          // A more advanced version could sample a texture.
          const color = mesh.material.isMeshStandardMaterial ? mesh.material.color : new THREE.Color(0xffffff);

          voxels.push({
            x: Math.round(point.x / voxelSize),
            y: Math.round(point.y / voxelSize),
            z: Math.round(point.z / voxelSize),
            color: color
          });
        }
      }
    }
  }

  // Center the resulting voxels around the origin
  if (voxels.length > 0) {
    let minX = Infinity, minY = Infinity, minZ = Infinity;
    voxels.forEach(v => {
      minX = Math.min(minX, v.x);
      minY = Math.min(minY, v.y);
      minZ = Math.min(minZ, v.z);
    });
    const centerX = Math.round(minX + (Math.max(...voxels.map(v=>v.x)) - minX) / 2);
    const centerY = Math.round(minY + (Math.max(...voxels.map(v=>v.y)) - minY) / 2);
    const centerZ = Math.round(minZ + (Math.max(...voxels.map(v=>v.z)) - minZ) / 2);
    
    voxels.forEach(v => {
      v.x -= centerX;
      v.y -= centerY;
      v.z -= centerZ;
    });
  }

  console.log(`Voxelization complete. Generated ${voxels.length} voxels.`);
  return voxels;
}


/**
 * Main function: Loads a GLB file and processes it into voxel data.
 * @param {File} file - The GLB file from an input.
 * @param {Object} options - Containing options like 'resolution'.
 * @returns {Promise<Array<Object>>} A promise that resolves with the voxel array.
 */
export async function processGlbToVoxels(file, options = {}) {
  const resolution = options.resolution || 25; // Default resolution

  if (!file || !file.name.toLowerCase().endsWith('.glb')) {
    throw new Error('Please select a valid .glb file.');
  }

  try {
    const mesh = await loadMeshFromGlb(file);
    const voxels = voxelizeMesh(mesh, resolution);
    return voxels;
  } catch (error) {
    console.error('[GLB Processor] Error:', error);
    throw error; // Re-throw to be caught by the UI layer
  }
}
ç¬¬2æ­¥: ä¿®æ”¹ world_simulator.js ä»¥é›†æˆGLBå¯¼å…¥

æ·»åŠ  Import å’Œæ–°çŠ¶æ€

// åœ¨æ–‡ä»¶é¡¶éƒ¨
import { processGlbToVoxels } from './glb-processor';

const VoxelWorldEditor = () => {
  // ... å…¶ä»–ç°æœ‰çŠ¶æ€
  const fileInputRef = useRef(null); // Ref for the hidden file input

  // æ–°å¢ï¼šGLBå¤„ç†ç›¸å…³çš„çŠ¶æ€
  const [isProcessingGlb, setIsProcessingGlb] = useState(false);
  const [glbError, setGlbError] = useState(null);

  // ...

æ·»åŠ äº‹ä»¶å¤„ç†å™¨

åœ¨ VoxelWorldEditor ç»„ä»¶å‡½æ•°ä½“å†…éƒ¨ï¼Œreturn è¯­å¥ä¹‹å‰ï¼Œæ·»åŠ ä»¥ä¸‹å¤„ç†å™¨ã€‚

code
JavaScript
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
// æ–°å¢ï¼šGLBæ–‡ä»¶é€‰æ‹©çš„äº‹ä»¶å¤„ç†å™¨
const handleGlbFileSelected = async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  setIsProcessingGlb(true);
  setGlbError(null);

  try {
    // è°ƒç”¨æˆ‘ä»¬çš„GLBå¤„ç†å™¨æ ¸å¿ƒé€»è¾‘
    const voxels = await processGlbToVoxels(file, { resolution: 25 });

    if (voxels && voxels.length > 0) {
      // ä½¿ç”¨é€šç”¨çš„addItemToBackpackå‡½æ•°
      addItemToBackpack(voxels);
      alert(`æˆåŠŸä»GLBæ–‡ä»¶ç”Ÿæˆäº† ${voxels.length} ä¸ªæ–¹å—çš„ç‰©å“ï¼`);
    } else {
      setGlbError("æ— æ³•ä»GLBæ–‡ä»¶ä¸­ç”Ÿæˆä»»ä½•æ–¹å—ã€‚æ¨¡å‹å¯èƒ½å¤ªå°æˆ–æ ¼å¼æœ‰é—®é¢˜ã€‚");
    }
  } catch (error) {
    setGlbError(error.message || "å¤„ç†GLBæ–‡ä»¶æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯ã€‚");
  } finally {
    setIsProcessingGlb(false);
    // é‡ç½®æ–‡ä»¶è¾“å…¥ï¼Œä»¥ä¾¿ç”¨æˆ·å¯ä»¥å†æ¬¡é€‰æ‹©ç›¸åŒçš„æ–‡ä»¶
    event.target.value = null; 
  }
};

// æ–°å¢ï¼šç‚¹å‡»å¯¼å…¥æŒ‰é’®æ—¶è§¦å‘éšè—çš„æ–‡ä»¶è¾“å…¥æ¡†
const handleImportGlbClick = () => {
  fileInputRef.current?.click();
};

ä¿®æ”¹ JSX

åœ¨è‰å›¾ç¼–è¾‘å™¨çš„â€œæ“ä½œæŒ‰é’®â€éƒ¨åˆ†ï¼Œæ·»åŠ æ–°çš„â€œå¯¼å…¥GLBâ€æŒ‰é’®ã€‚å¹¶åœ¨ç»„ä»¶çš„æŸä¸ªåœ°æ–¹ï¼ˆä¾‹å¦‚æ ¹ div çš„æœ«å°¾ï¼‰æ·»åŠ éšè—çš„æ–‡ä»¶è¾“å…¥æ¡†ã€‚


// ä¿®æ”¹ï¼šæ“ä½œæŒ‰é’®
<div className="flex gap-2 flex-wrap">
  {/* ... å…¶ä»–æŒ‰é’® ... */}
  <button
    onClick={handleImportGlbClick}
    disabled={isProcessingGlb}
    className="flex-1 px-4 py-2 bg-orange-500 text-white rounded hover:bg-orange-600 font-medium disabled:bg-orange-300"
    title="ä».glbæ–‡ä»¶å¯¼å…¥æ¨¡å‹"
  >
    {isProcessingGlb ? 'å¤„ç†ä¸­...' : 'ğŸ“¦ å¯¼å…¥GLB'}
  </button>
</div>

{/* æ–°å¢ï¼šå…¨å±€é”™è¯¯æç¤º */}
{glbError && (
  <div className="mt-4 p-2 bg-red-100 text-red-700 rounded text-sm">
    <strong>å¯¼å…¥é”™è¯¯:</strong> {glbError}
  </div>
)}

åœ¨ VoxelWorldEditor ç»„ä»¶è¿”å›çš„æ ¹ div çš„æœ«å°¾ï¼ˆä½†åœ¨ </div> ä¹‹å‰ï¼‰æ·»åŠ éšè—çš„æ–‡ä»¶è¾“å…¥æ¡†ã€‚

code
Jsx
download
content_copy
expand_less
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END
{/* ...å…¶ä»–JSX... */}

  {/* æ–°å¢ï¼šéšè—çš„æ–‡ä»¶è¾“å…¥æ¡†ï¼Œç”¨äºGLBå¯¼å…¥ */}
  <input
    type="file"
    ref={fileInputRef}
    onChange={handleGlbFileSelected}
    accept=".glb"
    style={{ display: 'none' }}
  />
</div>
);
æ€»ç»“

é€šè¿‡è¿™äº›ä¿®æ”¹ï¼Œæ‚¨ç°åœ¨æ‹¥æœ‰äº†ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„æ–°æ¨¡å¼ï¼š

ç”¨æˆ·ç‚¹å‡»â€œå¯¼å…¥GLBâ€ï¼Œä¸€ä¸ªæ–‡ä»¶é€‰æ‹©å™¨ä¼šæ‰“å¼€ã€‚

ç”¨æˆ·é€‰æ‹©ä¸€ä¸ª .glb æ–‡ä»¶ã€‚

glb-processor.js è¢«è°ƒç”¨ï¼Œå®ƒä¼šå¼‚æ­¥åŠ è½½æ¨¡å‹ã€‚

åŠ è½½æˆåŠŸåï¼Œå®ƒä¼šéå†æ¨¡å‹çš„è¾¹ç•Œæ¡†ï¼Œé€šè¿‡å…‰çº¿æŠ•å°„ç®—æ³•åˆ¤æ–­å“ªäº›ç©ºé—´ç‚¹åœ¨æ¨¡å‹å†…éƒ¨ï¼Œä»è€Œå°†æ¨¡å‹ä½“ç´ åŒ–ã€‚

æœ€ç»ˆç”Ÿæˆçš„ä½“ç´ æ•°ç»„è¢«ä¼ é€’å› VoxelWorldEditorã€‚

ä¸€ä¸ªåŒ…å«æ–°ä½“ç´ çš„æ–°ç‰©å“è¢«åˆ›å»ºå¹¶åŠ å…¥èƒŒåŒ…ï¼Œå¯ä»¥åƒå…¶ä»–ä»»ä½•ç‰©å“ä¸€æ ·è¢«æ”¾ç½®åˆ°3Dä¸–ç•Œä¸­ã€‚